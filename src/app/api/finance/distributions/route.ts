import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { z } from 'zod'

export const runtime = 'nodejs'
export const maxDuration = 60

// Validation schemas
const distributionSchema = z.object({
  partnerId: z.number().min(1),
  periodStart: z.string().or(z.date()),
  periodEnd: z.string().or(z.date()),
  totalRevenue: z.number().min(0),
  shareAmount: z.number().min(0),
  status: z.enum(['PENDING', 'COMPLETED', 'CANCELLED']).default('PENDING'),
  paymentDate: z.string().or(z.date()).optional().nullable(),
  paymentMethod: z.string().optional().nullable(),
  notes: z.string().optional().nullable(),
})

const calculateDistributionSchema = z.object({
  partnerId: z.number().optional(),
  periodStart: z.string().or(z.date()),
  periodEnd: z.string().or(z.date()),
  country: z.string().optional(),
})

// GET - Fetch all partner distributions
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url)
    const partnerId = searchParams.get('partnerId')
    const status = searchParams.get('status')
    const limit = parseInt(searchParams.get('limit') || '10', 10)
    const page = parseInt(searchParams.get('page') || '1', 10)
    const skip = (page - 1) * limit

    const where: any = {}

    if (partnerId) {
      where.partnerId = parseInt(partnerId)
    }

    if (status) {
      where.status = status
    }

    const [distributions, total] = await Promise.all([
      prisma.partnerDistribution.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
        include: {
          partner: {
            select: {
              id: true,
              name: true,
              partnerType: true,
              sharePercentage: true,
            },
          },
        },
      }),
      prisma.partnerDistribution.count({ where }),
    ])

    return NextResponse.json({
      data: distributions,
      total,
      page,
      limit,
    })
  } catch (error) {
    console.error('Error fetching distributions:', error)
    return NextResponse.json(
      { error: 'Failed to fetch distributions' },
      { status: 500 }
    )
  }
}

// POST - Calculate and create distribution for a period
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { action, ...data } = body

    // If action is calculate, compute distributions
    if (action === 'calculate') {
      const validation = calculateDistributionSchema.safeParse(data)

      if (!validation.success) {
        return NextResponse.json(
          { error: validation.error.errors[0].message },
          { status: 400 }
        )
      }

      const { partnerId, periodStart, periodEnd, country } = validation.data

      // Parse dates as local timezone, not UTC
      // "2025-11-15" should be Nov 15 00:00 in server's local time (Pakistan)
      const [startYear, startMonth, startDay] = periodStart.toString().split(/[-T]/).slice(0, 3).map(Number)
      const periodStartDate = new Date(startYear, startMonth - 1, startDay, 0, 0, 0, 0)

      const [endYear, endMonth, endDay] = periodEnd.toString().split(/[-T]/).slice(0, 3).map(Number)
      const periodEndDate = new Date(endYear, endMonth - 1, endDay, 23, 59, 59, 999)

      console.log('[CNS Distribution] Calculating for period:', {
        periodStart: periodStartDate.toISOString(),
        periodEnd: periodEndDate.toISOString(),
        periodStartLocal: periodStartDate.toString(),
        periodEndLocal: periodEndDate.toString(),
        partnerId: partnerId || 'all'
      })

      // First, let's see what transactions exist
      const allTransactions = await prisma.transaction.findMany({
        where: {
          status: 'COMPLETED',
        },
        select: {
          id: true,
          amount: true,
          transactionDate: true,
          isAutoGenerated: true,
        },
        orderBy: { transactionDate: 'desc' },
        take: 10
      })

      console.log('[CNS Distribution] Recent completed transactions:', allTransactions.map(t => ({
        id: t.id,
        amount: t.amount,
        date: t.transactionDate.toISOString(),
        dateLocal: t.transactionDate.toString(),
        isAuto: t.isAutoGenerated,
        inRange: t.transactionDate >= periodStartDate && t.transactionDate <= periodEndDate
      })))

      // Build country-based checkout ID filter for revenue calculation
      let revenueWhere: any = {
        status: 'COMPLETED',
        transactionDate: {
          gte: periodStartDate,
          lte: periodEndDate,
        },
      }
      if (country && country !== 'all') {
        const checkouts = await prisma.checkout.findMany({
          where: {
            items: {
              some: {
                OR: [
                  { product: { company: { country } } },
                  { animal: { country } },
                ],
              },
            },
          },
          select: { id: true },
        })
        const checkoutIds = checkouts.map((c) => c.id)
        revenueWhere.OR = [
          { checkoutId: { in: checkoutIds } },
          { checkoutId: null },
        ]
      }

      // Get revenue for the period
      const revenue = await prisma.transaction.aggregate({
        where: revenueWhere,
        _sum: {
          amount: true,
        },
      })

      const totalRevenue = revenue._sum.amount || 0

      console.log('[CNS Distribution] Revenue calculated:', {
        totalRevenue,
        rawSum: revenue._sum.amount
      })

      // Get partners to distribute to
      const partnersQuery = partnerId
        ? { where: { id: partnerId, isActive: true } }
        : { where: { isActive: true } }

      const partners = await prisma.businessPartner.findMany(partnersQuery)

      const calculations = partners.map((partner) => ({
        partnerId: partner.id,
        partnerName: partner.name,
        sharePercentage: partner.sharePercentage,
        totalRevenue,
        shareAmount: (totalRevenue * partner.sharePercentage) / 100,
        periodStart: new Date(periodStart),
        periodEnd: new Date(periodEnd),
      }))

      return NextResponse.json({
        calculations,
        totalRevenue,
        periodStart,
        periodEnd,
      })
    }

    // Otherwise, create the distribution record
    const validation = distributionSchema.safeParse(data)

    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      )
    }

    const distribution = await prisma.partnerDistribution.create({
      data: {
        ...validation.data,
        periodStart: new Date(validation.data.periodStart),
        periodEnd: new Date(validation.data.periodEnd),
        paymentDate: validation.data.paymentDate
          ? new Date(validation.data.paymentDate)
          : null,
      },
      include: {
        partner: true,
      },
    })

    // If status is COMPLETED, create an expense record for the distribution
    if (validation.data.status === 'COMPLETED') {
      await prisma.expense.create({
        data: {
          category: 'PARTNER_DISTRIBUTION',
          amount: validation.data.shareAmount,
          description: `Partner distribution to ${distribution.partner.name} for period ${new Date(
            validation.data.periodStart
          ).toLocaleDateString()} - ${new Date(validation.data.periodEnd).toLocaleDateString()}`,
          expenseDate: validation.data.paymentDate
            ? new Date(validation.data.paymentDate)
            : new Date(),
          paymentMethod: validation.data.paymentMethod,
          status: 'COMPLETED',
          partnerId: validation.data.partnerId,
          notes: validation.data.notes,
        },
      })
    }

    return NextResponse.json(distribution, { status: 201 })
  } catch (error) {
    console.error('Error creating distribution:', error)
    return NextResponse.json(
      { error: 'Failed to create distribution' },
      { status: 500 }
    )
  }
}

// PUT - Update distribution status
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json()
    const { id, ...updateData } = body

    if (!id) {
      return NextResponse.json(
        { error: 'Distribution ID is required' },
        { status: 400 }
      )
    }

    const validation = distributionSchema.partial().safeParse(updateData)

    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      )
    }

    const dataToUpdate: any = { ...validation.data }
    if (dataToUpdate.periodStart) {
      dataToUpdate.periodStart = new Date(dataToUpdate.periodStart)
    }
    if (dataToUpdate.periodEnd) {
      dataToUpdate.periodEnd = new Date(dataToUpdate.periodEnd)
    }
    if (dataToUpdate.paymentDate) {
      dataToUpdate.paymentDate = new Date(dataToUpdate.paymentDate)
    }

    const distribution = await prisma.partnerDistribution.update({
      where: { id: parseInt(id) },
      data: dataToUpdate,
      include: {
        partner: true,
      },
    })

    // If status changed to COMPLETED, create/update expense record
    if (dataToUpdate.status === 'COMPLETED') {
      const existingExpense = await prisma.expense.findFirst({
        where: {
          category: 'PARTNER_DISTRIBUTION',
          partnerId: distribution.partnerId,
          description: {
            contains: `Partner distribution to ${distribution.partner.name}`,
          },
        },
      })

      if (!existingExpense) {
        await prisma.expense.create({
          data: {
            category: 'PARTNER_DISTRIBUTION',
            amount: distribution.shareAmount,
            description: `Partner distribution to ${distribution.partner.name} for period ${distribution.periodStart.toLocaleDateString()} - ${distribution.periodEnd.toLocaleDateString()}`,
            expenseDate: distribution.paymentDate || new Date(),
            paymentMethod: distribution.paymentMethod,
            status: 'COMPLETED',
            partnerId: distribution.partnerId,
            notes: distribution.notes,
          },
        })
      }
    }

    return NextResponse.json(distribution)
  } catch (error) {
    console.error('Error updating distribution:', error)
    return NextResponse.json(
      { error: 'Failed to update distribution' },
      { status: 500 }
    )
  }
}

// DELETE - Delete distribution
export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const id = searchParams.get('id')

    if (!id) {
      return NextResponse.json(
        { error: 'Distribution ID is required' },
        { status: 400 }
      )
    }

    await prisma.partnerDistribution.delete({
      where: { id: parseInt(id) },
    })

    return NextResponse.json(
      { message: 'Distribution deleted successfully' },
      { status: 200 }
    )
  } catch (error) {
    console.error('Error deleting distribution:', error)
    return NextResponse.json(
      { error: 'Failed to delete distribution' },
      { status: 500 }
    )
  }
}
