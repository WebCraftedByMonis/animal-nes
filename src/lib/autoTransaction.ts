import { prisma } from '@/lib/prisma'

export interface AutoTransactionData {
  type: 'PRODUCT_SALE' | 'ANIMAL_SALE' | 'CONSULTATION_FEE' | 'ADDITIONAL_CONSULTATION' | 'OTHER_INCOME'
  amount: number
  costPrice?: number
  profit?: number
  description: string
  paymentMethod?: string
  checkoutId?: number
  checkoutItemId?: number
  appointmentId?: number
  additionalFeeId?: number
  status?: 'PENDING' | 'COMPLETED' | 'CANCELLED'
}

/**
 * Auto-creates a transaction record in the CNS system
 * Called automatically when sales/payments occur
 */
export async function createAutoTransaction(data: AutoTransactionData) {
  try {
    // The amount should be the PROFIT (revenue - cost), not the revenue
    // Store revenue in costPrice field temporarily, actual cost in profit field
    // Then calculate the actual profit
    const actualProfit = data.profit !== null && data.profit !== undefined ? data.profit : data.amount

    const transaction = await prisma.transaction.create({
      data: {
        type: data.type,
        amount: actualProfit, // Store PROFIT as the main amount (this is our actual income)
        costPrice: data.costPrice || null, // Purchase cost
        profit: data.profit || null, // Calculated profit for reference
        description: data.description,
        transactionDate: new Date(),
        paymentMethod: data.paymentMethod || null,
        status: data.status || 'COMPLETED',
        isAutoGenerated: true,
        checkoutId: data.checkoutId || null,
        checkoutItemId: data.checkoutItemId || null,
        appointmentId: data.appointmentId || null,
        additionalFeeId: data.additionalFeeId || null,
        notes: data.profit !== null && data.profit !== undefined
          ? `Revenue: PKR ${data.amount.toFixed(2)} | Cost: PKR ${(data.costPrice || 0).toFixed(2)} | Profit: PKR ${data.profit.toFixed(2)}`
          : 'Auto-generated transaction',
      },
    })

    console.log(`[CNS] Auto-created transaction #${transaction.id}: ${data.type} - Revenue: ${data.amount}, Cost: ${data.costPrice || 0}, Profit: ${data.profit || 0}`)
    return transaction
  } catch (error) {
    console.error('[CNS] Failed to create auto-transaction:', error)
    // Don't throw - we don't want to break the main transaction if CNS logging fails
    return null
  }
}

/**
 * Creates transaction for product sale with profit tracking
 */
export async function createProductSaleTransaction(
  checkoutId: number,
  checkoutItemId: number,
  revenue: number,
  costPrice: number | null,
  productName: string,
  paymentMethod?: string
) {
  const profit = costPrice !== null ? revenue - costPrice : revenue

  return createAutoTransaction({
    type: 'PRODUCT_SALE',
    amount: revenue, // Pass revenue to createAutoTransaction
    costPrice: costPrice || undefined,
    profit: profit, // Calculated profit
    description: `Product Sale: ${productName}`,
    paymentMethod,
    checkoutId,
    checkoutItemId,
    status: 'COMPLETED',
  })
}

/**
 * Creates transaction for animal sale with profit tracking
 */
export async function createAnimalSaleTransaction(
  checkoutId: number,
  checkoutItemId: number,
  revenue: number,
  costPrice: number | null,
  animalName: string,
  paymentMethod?: string
) {
  const profit = costPrice !== null ? revenue - costPrice : revenue

  return createAutoTransaction({
    type: 'ANIMAL_SALE',
    amount: revenue, // Pass revenue to createAutoTransaction
    costPrice: costPrice || undefined,
    profit: profit, // Calculated profit
    description: `Animal Sale: ${animalName}`,
    paymentMethod,
    checkoutId,
    checkoutItemId,
    status: 'COMPLETED',
  })
}

/**
 * Updates transaction profit when prices are edited
 */
export async function updateTransactionProfit(
  checkoutItemId: number,
  newSellingPrice: number,
  newPurchasePrice: number | null
) {
  try {
    const profit = newPurchasePrice !== null ? newSellingPrice - newPurchasePrice : newSellingPrice

    const transaction = await prisma.transaction.updateMany({
      where: {
        checkoutItemId: checkoutItemId,
        isAutoGenerated: true
      },
      data: {
        amount: profit, // Store PROFIT as the main amount (our actual income)
        costPrice: newPurchasePrice,
        profit: profit,
        notes: newPurchasePrice !== null
          ? `Revenue: PKR ${newSellingPrice.toFixed(2)} | Cost: PKR ${newPurchasePrice.toFixed(2)} | Profit: PKR ${profit.toFixed(2)} (Updated)`
          : `Revenue: PKR ${newSellingPrice.toFixed(2)} | Profit: PKR ${profit.toFixed(2)} (Updated)`,
        updatedAt: new Date()
      }
    })

    console.log(`[CNS] Updated transaction profit for item #${checkoutItemId}: Revenue: ${newSellingPrice}, Cost: ${newPurchasePrice || 0}, Profit: ${profit}`)
    return transaction
  } catch (error) {
    console.error('[CNS] Failed to update transaction profit:', error)
    return null
  }
}

/**
 * Creates transaction for appointment consultation fee
 */
export async function createConsultationFeeTransaction(
  appointmentId: number,
  amount: number,
  doctorName: string,
  paymentMethod?: string
) {
  return createAutoTransaction({
    type: 'CONSULTATION_FEE',
    amount,
    description: `Consultation Fee - Dr. ${doctorName}`,
    paymentMethod,
    appointmentId,
    status: 'COMPLETED',
  })
}

/**
 * Creates transaction for additional consultation fee
 */
export async function createAdditionalConsultationTransaction(
  additionalFeeId: number,
  appointmentId: number,
  amount: number,
  description: string,
  paymentMethod?: string
) {
  return createAutoTransaction({
    type: 'ADDITIONAL_CONSULTATION',
    amount,
    description: `Additional Fee: ${description}`,
    paymentMethod,
    appointmentId,
    additionalFeeId,
    status: 'COMPLETED',
  })
}
